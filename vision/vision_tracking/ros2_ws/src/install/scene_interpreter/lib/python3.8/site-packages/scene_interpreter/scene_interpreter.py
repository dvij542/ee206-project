from .ball_state_estimator_yolo import estimate_ball_3D_spatial_coords

import rclpy
from rclpy.node import Node
from geometry_msgs.msg import Point
from interface.msg import Scene

from cv_bridge import CvBridge
import time


class SceneInterpreter(Node):

    def __init__(self):
        super().__init__('scene_interpreter')

        self.subscription = self.create_subscription(
            Scene,
            "sync_scene",
            self.listener_callback,
            10
        )
        self.sci_publisher = self.create_publisher(Scene, "annotated_sync_scene", 10)
        self.br = CvBridge()
        self.get_logger().info('Initialized.')

        # Ask the user whether to display annotated video feeds
        self.display_annotated_video = input("Would you like to display annotated video feeds (yes/no)? ").strip().lower() == "yes"

    def listener_callback(self, scene):
        start = time.time()

        # Convert scene frames to OpenCV format
        frames = [self.br.imgmsg_to_cv2(frame) for frame in scene.frames]

        # Pass all available frames to the helper function
        ball_spatial_coords, error = estimate_ball_3D_spatial_coords(*frames, display_annotated=self.display_annotated_video)

        if ball_spatial_coords is None:
            self.get_logger().warn("Failed to estimate 3D ball coordinates. Skipping frame.")
        else:
            self.get_logger().info(f"Estimated 3D Ball Coordinates: {ball_spatial_coords} with error {error:.2f}")
            p = Point()
            p.x, p.y, p.z = ball_spatial_coords[:3]
            scene.ball_spatial_coords = p
            self.sci_publisher.publish(scene)

        end = time.time()
        self.get_logger().info(f"Processed frame in {end - start:.2f} seconds.")

    def cleanup(self):
        # Ensure OpenCV windows are closed if used
        if self.display_annotated_video:
            cv2.destroyAllWindows()


def main(args=None):
    rclpy.init(args=args)

    sci = SceneInterpreter()
    try:
        rclpy.spin(sci)
    except KeyboardInterrupt:
        pass
    finally:
        sci.cleanup()
        sci.destroy_node()
        rclpy.shutdown()



if __name__ == '__main__':
    main()
