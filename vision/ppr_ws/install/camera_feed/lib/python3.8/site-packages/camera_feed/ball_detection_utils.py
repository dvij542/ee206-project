import cv2
import imutils
import numpy as np
import queue


def detect_ball_BGR_hough_circles(frame):
    lower_BGR = (20, 50, 80)
    upper_BGR = (170, 212, 245)

    mask1 = cv2.inRange(frame, lower_BGR, upper_BGR)
    blue, green, red = cv2.split(frame)
    red2 = (red - 22).astype(np.uint8)
    blue2 = (blue).astype(np.uint8)
    mask2 = cv2.compare(red2, green, cv2.CMP_GT)
    mask3 = cv2.compare(green, blue2, cv2.CMP_GT)
    mask = cv2.bitwise_and(mask1, mask2)
    mask = cv2.bitwise_and(mask, mask3)
    cv2.imshow("hsv_mask", mask)
    circles = cv2.HoughCircles(mask, cv2.HOUGH_GRADIENT, 1,
                               mask.shape[0]/3, param1=100, param2=10, minRadius=2, maxRadius=20)
    if circles is None:
        return None, None
    c = circles[0, :][0]
    center = (int(c[0]), int(c[1]))
    radius = c[2]

    return center, radius


def area_filter(x):
    area = cv2.contourArea(x)
    return area < 1500 and area > 200

def area_filter_lax(x):
    area = cv2.contourArea(x)
    return area < 2000 and area > 250

def distance_filter(cnt, prev_x, prev_y, radius):
    dist = cv2.pointPolygonTest(cnt,(prev_x,prev_y),True)
    return dist < radius

def generate_contours(frame, prev_center=None, max_distance=None, show_mask=False):
    lower_BGR = (20, 50, 80)
    upper_BGR = (170, 212, 245)
    if max_distance:
        circle_mask = np.zeros_like(frame)
        circle_mask = cv2.circle(circle_mask, prev_center, max_distance, (255,255,255), -1)
    else:
        circle_mask = np.ones_like(frame)
    frame = cv2.bitwise_and(frame, circle_mask)
    mask1 = cv2.inRange(frame, lower_BGR, upper_BGR)
    blue, green, red = cv2.split(frame)
    red_abs = (red - 18).astype(np.uint8)
    red_prop = (red/1.3).astype(np.uint8)
    blue2 = (blue*1.2).astype(np.uint8)
    mask2 = cv2.compare(red_abs, green, cv2.CMP_GT)
    mask3 = cv2.compare(red_prop, green, cv2.CMP_GT)
    mask4 = cv2.compare(green, blue2, cv2.CMP_GT)

    # make a base red threshold, improves phantom detections a bit

    mask1 = cv2.bitwise_and(mask1, mask2)
    mask2 = cv2.bitwise_and(mask3, mask4)
    mask = cv2.bitwise_and(mask1, mask2)
    if (show_mask):
        cv2.imshow("search_mask", mask)
    cnts = cv2.findContours(
        mask.copy(), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    cnts = imutils.grab_contours(cnts)
    #print([cv2.contourArea(cnt) for cnt in cnts])
    cnts = list(filter(area_filter, cnts))
    return cnts

def generate_contours_lax(frame, prev_center, max_distance, show_mask=False):
    lower_BGR = (10, 30, 60)
    upper_BGR = (170, 212, 245)
    if max_distance:
        circle_mask = np.zeros_like(frame)
        circle_mask = cv2.circle(circle_mask, prev_center, max_distance, (255,255,255), -1)
    else:
        circle_mask = np.ones_like(frame)
    frame = cv2.bitwise_and(frame, circle_mask)
    mask1 = cv2.inRange(frame, lower_BGR, upper_BGR)
    _, green, red = cv2.split(frame)
    red_abs = (red - 10).astype(np.uint8)
    red_prop = (red/1.15).astype(np.uint8)
    mask2 = cv2.compare(red_abs, green, cv2.CMP_GT)
    mask3 = cv2.compare(red_prop, green, cv2.CMP_GT)

    # make a base red threshold, improves phantom detections a bit

    mask1 = cv2.bitwise_and(mask1, mask2)
    mask = cv2.bitwise_and(mask1, mask3)
    if (show_mask):
        cv2.imshow("search_mask", mask)
    cnts = cv2.findContours(
        mask.copy(), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    cnts = imutils.grab_contours(cnts)
    #print([cv2.contourArea(cnt) for cnt in cnts])
    cnts = list(filter(area_filter_lax, cnts))
    return cnts

def detect_ball_dynamic(frame, prev_center = None, max_distance = None, show_mask = False, find_front=False):
    if (max_distance == None or max_distance > 200):
        return detect_ball_contours(frame, prev_center, max_distance, show_mask, find_front)
    else:
        cnts = generate_contours_lax(frame, prev_center, max_distance, show_mask)
        center = None
        radius = None
        x = None
        y = None
        front_center, front_radius = None, None
        if len(cnts) > 0:
            # print(cnts)
            # print("found some contours")
            c = max(cnts, key=cv2.contourArea)
            # print(cv2.contourArea(c))
            ((x, y), radius) = cv2.minEnclosingCircle(c)
            if find_front:
                front_center, front_radius = ball_front_from_contour(c, prev_center, static_rad=10)
            # print((x, y))
            # print(radius)
            M = cv2.moments(c)
            center = (int(M["m10"] / M["m00"]), int(M["m01"] / M["m00"]))
        # update the points queue
        if x and radius > 7:
            center = (int(x), int(y))
        if find_front:
            return center, radius, front_center, front_radius
        else:
            return center, radius

def detect_ball_contours(frame, prev_center = None, max_distance = None, show_mask = False, find_front=False):
    cnts = generate_contours(frame, prev_center, max_distance, show_mask)
    center = None
    radius = None
    x = None
    y = None
    front_center, front_radius = None, None
    if len(cnts) > 0:
        # print(cnts)
        # print("found some contours")
        c = max(cnts, key=cv2.contourArea)
        # print(cv2.contourArea(c))
        ((x, y), radius) = cv2.minEnclosingCircle(c)
        if find_front:
            front_center, front_radius = ball_front_from_contour(c, prev_center, static_rad=10)
        # print((x, y))
        # print(radius)
        M = cv2.moments(c)
        center = (int(M["m10"] / M["m00"]), int(M["m01"] / M["m00"]))
    # update the points queue
    if x and radius > 7:
        center = (int(x), int(y))
    if find_front:
        return center, radius, front_center, front_radius
    else:
        return center, radius
     
def ball_front_from_contour(contour, prev_center, corr=8, static_rad=-1):
    midpt = None
    rad = static_rad
    if prev_center != None:
        rect = cv2.minAreaRect(contour)
        curr_pts = cv2.boxPoints(rect)
        max_dist_pt = max(curr_pts, key=lambda x: np.linalg.norm(np.array(prev_center) - np.array(x)))
        without = curr_pts.tolist()
        without.remove(max_dist_pt.tolist()) # it seems removing an element from a 2D np array in a "proper" way has more steps than this
        without = np.array(without)
        pair_pt = min(without, key=lambda x: np.linalg.norm(np.array(max_dist_pt) - np.array(x)))
        midpt = 0.5 * (max_dist_pt + pair_pt) 
        without = without.tolist()
        without.remove(pair_pt.tolist())
        without = np.array(without)
        opp_midpt = 0.5 * (without[0] + without[1]) 
        back_vec = (midpt - opp_midpt) / np.linalg.norm(midpt - opp_midpt)
        midpt -= corr * back_vec # correction for imprecision of mask; could make this more dynamic
        if static_rad < 0:
            rad = np.linalg.norm(midpt - pair_pt)
    return (int(midpt[0]), int(midpt[1])), rad

def detect_ball_hough_circles_test(frame):
    
    # blurred = cv2.GaussianBlur(frame, (11, 11), 0)

    lower_BGR = (20, 50, 80)
    upper_BGR = (170, 212, 255)
    mask1 = cv2.inRange(frame, lower_BGR, upper_BGR)

    base_red_lower = (0, 0, 115)
    base_red_upper = (255, 255, 255)

    mask_red = cv2.inRange(frame, base_red_lower, base_red_upper)

    blue, green, red = cv2.split(frame)
    red2 = (red - 22).astype(np.uint8)
    blue2 = (blue).astype(np.uint8)
    mask2 = cv2.compare(red2, green, cv2.CMP_GT)

    mask3 = cv2.compare(green, blue2, cv2.CMP_GT)

    mask_red = cv2.inRange(frame, base_red_lower, base_red_upper)

    mask = cv2.bitwise_and(mask1, mask2)
    mask = cv2.bitwise_and(mask, mask3)
    
    mask = cv2.bitwise_and(mask, mask_red)

    close_struct = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (15, 15))
    open_struct = cv2.getStructuringElement(cv2.MORPH_RECT, (3, 3))
    
    mask = cv2.morphologyEx(mask, cv2.MORPH_OPEN, open_struct)
    mask = cv2.morphologyEx(mask, cv2.MORPH_CLOSE, close_struct)

    hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)
    
    cv2.imshow("erode_dilate_mask", mask)

    # circles = cv2.HoughCircles(mask, cv2.HOUGH_GRADIENT, 1,
    #                            mask.shape[0]/3, param1=100, param2=10, minRadius=5, maxRadius=20)
    # if circles is None:
    #     return None, None
    # c = circles[0, :][0]
    # center = (int(c[0]), int(c[1]))
    # radius = c[2]

    cnts = cv2.findContours(
        mask.copy(), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    cnts = imutils.grab_contours(cnts)

    center = None
    radius = None
    x = None
    y = None
    cnts = list(filter(area_filter, cnts))
    if len(cnts) > 0:
        # print(cnts)
        # print("found some contours")
        c = max(cnts, key=cv2.contourArea)
        # print(cv2.contourArea(c))
        ((x, y), radius) = cv2.minEnclosingCircle(c)
        # print((x, y))
        # print(radius)
        M = cv2.moments(c)
        center = (int(M["m10"] / M["m00"]), int(M["m01"] / M["m00"]))

    return center, radius

def detect_ball_in_motion_memory(frame, buffer_queue=queue.Queue(1), local_search_dist = 50, show_mask = False):

    lower_BGR = (20, 50, 80)
    upper_BGR = (170, 212, 255)

    search_angle = np.pi/3
    
    # thoughts: if buffer fills, flush it and perform a search on the whole frame
    # should happen every "buffer size"th detection.
    if buffer_queue.full:
        buffer_queue.queue.clear()

    search_mask = np.zeros_like(frame)
    buffer_first = buffer_queue.get()
    # buffer_second = buffer_queue.get()

    # pixel_vel = buffer_first[0] - buffer_second[0]
    # search_poly = np.array([buffer_first[0], buffer_first[0] + pixel_vel, ])

    if buffer_first:
        for frame_data in buffer_queue:
            ball_center = frame_data[0]
            search_mask = cv2.circle(search_mask, ball_center, local_search_dist, (255,255,255), -1)
    else:
        search_mask = np.ones_like(frame)

    frame = cv2.bitwise_and(frame, search_mask)

    mask1 = cv2.inRange(frame, lower_BGR, upper_BGR)
    blue, green, red = cv2.split(frame)
    red_abs = (red - 18).astype(np.uint8)
    red_prop = (red/1.3).astype(np.uint8)
    blue2 = (blue*1.2).astype(np.uint8)
    mask2 = cv2.compare(red_abs, green, cv2.CMP_GT)
    mask3 = cv2.compare(red_prop, green, cv2.CMP_GT)
    mask4 = cv2.compare(green, blue2, cv2.CMP_GT)


    mask1 = cv2.bitwise_and(mask1, mask2)
    mask2 = cv2.bitwise_and(mask3, mask4)
    mask = cv2.bitwise_and(mask1, mask2)
    if (True):
        cv2.imshow("search_mask", frame)
    cnts = cv2.findContours(
        mask.copy(), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    cnts = imutils.grab_contours(cnts)

    center = None
    radius = 0
    cnts = list(filter(area_filter, cnts))
    if len(show_mask) > 0:
        c = max(cnts, key=cv2.contourArea)
        # print(cv2.contourArea(c))
        (center, radius) = cv2.minEnclosingCircle(c)

    if center and radius > 7:
        buffer_queue.put((center, radius))
        return center, radius
    else:
        buffer_queue.put((None, 0))
        return None, 0