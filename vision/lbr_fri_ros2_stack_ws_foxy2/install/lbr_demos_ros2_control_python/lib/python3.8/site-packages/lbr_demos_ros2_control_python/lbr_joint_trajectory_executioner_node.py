import rclpy
from control_msgs.action import FollowJointTrajectory
from rclpy.action import ActionClient
from rclpy.node import Node
from trajectory_msgs.msg import JointTrajectoryPoint
from lbr_fri_msgs.msg import JointPositionWithTime


class LBRJointTrajectoryExecutionerNode(Node):
    def __init__(
        self,
        node_name: str,
    ) -> None:
        super().__init__(node_name=node_name)
        self.joint_trajectory_action_client_ = ActionClient(
            node=self,
            action_type=FollowJointTrajectory,
            action_name="/joint_trajectory_controller/follow_joint_trajectory",
        )
        while not self.joint_trajectory_action_client_.wait_for_server(1):
            self.get_logger().info("Waiting for action server to become available...")
        self.get_logger().info("Action server available.")


        self.sub_ = self.create_subscription(
            JointPositionWithTime, "/desired_joint_position", self.listener_callback, 100
        )
        print("Ready")

    def listener_callback(self, message):
        # print(message)
        print("Callback")
        self.execute(message.theta, message.sec, message.nanosec)
        print("Finished")

    def execute(self, positions: list, sec, nanosec):
        print("Executing")
        if len(positions) != 7:
            self.get_logger().error("Invalid number of joint positions.")
            return

        joint_trajectory_goal = FollowJointTrajectory.Goal()
        goal_sec_tolerance = 1
        joint_trajectory_goal.goal_time_tolerance.sec = goal_sec_tolerance

        point = JointTrajectoryPoint()
        point.positions = positions.tolist()
        point.velocities = [0.0] * len(positions)
        point.effort = [0.0] * len(positions)
        point.time_from_start.sec = sec
        point.time_from_start.nanosec = nanosec

        for i in range(7):
            joint_trajectory_goal.trajectory.joint_names.append(f"A{i + 1}")

        joint_trajectory_goal.trajectory.points.append(point)

        # send goal
        goal_future = self.joint_trajectory_action_client_.send_goal_async(
            joint_trajectory_goal
        )
        timeout_secs = sec + nanosec * 10e-11
        print(f"Timeout: {timeout_secs}")
        rclpy.spin_until_future_complete(self, goal_future, timeout_sec=timeout_secs)
        print("Here")
        goal_handle = goal_future.result()
        print("Here2")
        if goal_handle == None:
            print("Here3")
            return
        if not goal_handle.accepted:
            self.get_logger().error("Goal was rejected by server.")
            print("Goal rejected")
            return
        self.get_logger().info("Goal was accepted by server.")
        print("Goal accepted")

        # wait for result
        result_future = goal_handle.get_result_async()
        rclpy.spin_until_future_complete(
            self, result_future, timeout_sec=sec_from_start + goal_sec_tolerance
        )
        print("Completed")

        if (
            result_future.result().result.error_code
            != FollowJointTrajectory.Result.SUCCESSFUL
        ):
            self.get_logger().error("Failed to execute joint trajectory.")
            print("Failed")
            return


def main(args: list = None) -> None:
    rclpy.init(args=args)
    lbr_joint_trajectory_executioner_node = LBRJointTrajectoryExecutionerNode(
        "lbr_joint_trajectory_executioner_node"
    )
    rclpy.spin(lbr_joint_trajectory_executioner_node)
    rclpy.shutdown()
