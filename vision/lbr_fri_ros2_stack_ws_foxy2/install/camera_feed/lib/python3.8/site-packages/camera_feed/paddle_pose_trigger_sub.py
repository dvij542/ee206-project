"""Subscribes to the OptiTrack system to collect paddle poses. 
Records a pose with every trigger signal.
Writes them to an npz file after recording."""

import rclpy
from rclpy.node import Node
from std_msgs.msg import Int32
from geometry_msgs.msg import PoseStamped
import numpy as np
import signal
from scipy.spatial.transform import Rotation as R
from scipy.spatial.transform import Rotation
import copy

R_spatial_optitrack = np.array([
    [1, 0, 0],
    [0, 0, 1],
    [0, -1, 0]
    ])

exit_flag = False
def signal_handler(sig, frame):
    global exit_flag
    exit_flag = True

def optitrack_to_spatial(paddle_pose):
    paddle_pose[:3] *= 100 # m to cm
    paddle_position = paddle_pose[:3]
    paddle_position_spatial = R_spatial_optitrack @ paddle_position

    paddle_quaternion = paddle_pose[3:]
    rotation_matrix = R.from_quat(paddle_quaternion).as_matrix()
    rotation_matrix_spatial = R_spatial_optitrack @ rotation_matrix
    rotation = Rotation.from_matrix(rotation_matrix_spatial)
    paddle_quaternion_spatial = rotation.as_quat()

    return np.concatenate((paddle_position_spatial, paddle_quaternion_spatial))

def post_process_pose(poses):
    poses = np.array([optitrack_to_spatial(pose) for pose in poses])
    return poses

class PaddlePoseTriggerSubscriberNode(Node):

    def __init__(self):
        super().__init__('paddle_pose_trigger_subscriber_node')

        self.declare_parameter('folder')
        self.folder = self.get_parameter('folder').get_parameter_value().string_value
        self.get_logger().info(self.folder)

        self.subscription = self.create_subscription(
            Int32, 
            'trigger',
            self.save_callback,
            1
        )
        self.poses_kuka = []
        self.poses_opponent = []

        self.subscription_kuka = self.create_subscription(
            PoseStamped, 
            '/vrpn_mocap/paddle_kuka/pose',
            self.optitrack_kuka_callback,
            10
        )
        self.buffer_kuka = None # needs to be initialized with a dummy value

        self.subscription_opponent = self.create_subscription(
            PoseStamped, 
            '/vrpn_mocap/paddle_opponent/pose',
            self.optitrack_opponent_callback,
            10
        )
        self.buffer_opponent = None

        # timer_period = 1.0 / 120.0  # 120Hz publishing frequency
        # self.timer = self.create_timer(timer_period, self.timer_callback)
        # self.counter = 0

        self.get_logger().info("Initialized.")

        timer_period = 1.0 / 2  # 100Hz publishing frequency
        self.timer = self.create_timer(timer_period, self.check_for_end_callback)

        self.publisher = self.create_publisher(Int32, f'paddle_pose_pub', 10)

    def save_callback(self, msg):
        if self.buffer_kuka is not None and self.buffer_opponent is not None:
            pose_kuka, pose_opponent = self.buffer_kuka.copy(), self.buffer_opponent.copy()
            self.poses_kuka.append(pose_kuka)
            self.poses_opponent.append(pose_opponent)

        self.get_logger().info('Received: %d' % msg.data)
        msg = Int32()
        msg.data = 0
        self.publisher.publish(msg)

        # Check the exit_flag to end the loop gracefully
        global exit_flag
        if exit_flag:
            self.get_logger().info('Exiting loop...')
            return

    def optitrack_kuka_callback(self, pose_stamped_msg):
        # self.get_logger().info('Received: %s' % str(pose_stamped_msg))
        # self.get_logger().info('Received: kuka')

        pose_stamped_msg = copy.deepcopy(pose_stamped_msg)
        position = [pose_stamped_msg.pose.position.x, pose_stamped_msg.pose.position.y, pose_stamped_msg.pose.position.z]
        orientation = [pose_stamped_msg.pose.orientation.x, pose_stamped_msg.pose.orientation.y, pose_stamped_msg.pose.orientation.z, pose_stamped_msg.pose.orientation.w]
        data = position + orientation
        self.buffer_kuka = np.array(data)

        # Check the exit_flag to end the loop gracefully
        global exit_flag
        if exit_flag:
            self.get_logger().info('Exiting loop...')
            return

    def optitrack_opponent_callback(self, pose_stamped_msg):
        # self.get_logger().info('Received: %s' % str(pose_stamped_msg))
        # self.get_logger().info('Received: opponent')

        pose_stamped_msg = copy.deepcopy(pose_stamped_msg)
        position = [pose_stamped_msg.pose.position.x, pose_stamped_msg.pose.position.y, pose_stamped_msg.pose.position.z]
        orientation = [pose_stamped_msg.pose.orientation.x, pose_stamped_msg.pose.orientation.y, pose_stamped_msg.pose.orientation.z, pose_stamped_msg.pose.orientation.w]
        data = position + orientation
        self.buffer_opponent = np.array(data)

        # Check the exit_flag to end the loop gracefully
        global exit_flag
        if exit_flag:
            self.get_logger().info('Exiting loop...')
            return

    def timer_callback(self):
        # self.get_logger().info('Received: %d' % msg.data)

        # Check the exit_flag to end the loop gracefully
        global exit_flag
        if exit_flag:
            self.get_logger().info('Exiting loop...')
            return

        if len(self.buffer) > 1000:
            self.buffer = self.buffer[-10:]

        # self.buffer.append(...)
        self.buffer.append(self.counter)
        self.counter += 1

    def check_for_end_callback(self):
        # Check the exit_flag to end the loop gracefully
        global exit_flag
        if exit_flag:
            self.get_logger().info('Exiting loop...')
            return

def main(args=None):
    # TODO: CHECK IF NPZ FILE ALREADY EXISTS
    overwrite = input("Are you overwriting something you shouldn't? ")
    if overwrite == 'q' or overwrite == 'Q':
        return
    input("Are the lights on?")
    rclpy.init(args=args)
    node = PaddlePoseTriggerSubscriberNode()
    signal.signal(signal.SIGINT, signal_handler)  # Set up the signal handler for Ctrl+C

    while rclpy.ok() and not exit_flag:
        rclpy.spin_once(node)

    assert len(node.poses_kuka) > 0 and len(node.poses_opponent) > 0
    base_path = f"/home/pingpongproject/code/ping-pong-robot/ppr_ws/src/camera_feed/camera_feed/data/{node.folder}"

    node.poses_kuka = post_process_pose(node.poses_kuka)
    node.poses_opponent = post_process_pose(node.poses_opponent)
    np.savez(
        f"{base_path}/paddle_poses.npz", 
        kuka = np.array(node.poses_kuka),
        opponent = np.array(node.poses_opponent),
    )
    print("saved")
    
    node.destroy_node()
    rclpy.shutdown()


if __name__ == '__main__':
    main()