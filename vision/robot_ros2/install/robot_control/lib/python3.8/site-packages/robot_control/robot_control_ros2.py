#!/usr/bin/env python3

from .mujoco_env_only_kuka import KukaTennisEnv
from stable_baselines3 import PPO

import rclpy
from rclpy.node import Node
from control_msgs.msg import JointTrajectoryControllerState
from trajectory_msgs.msg import JointTrajectory, JointTrajectoryPoint
from geometry_msgs.msg import Pose
from copy import deepcopy
from scipy.spatial.transform import Rotation as R
from ament_index_python.packages import get_package_share_directory
import numpy as np
import argparse
import math
import copy
import os

parser = argparse.ArgumentParser()
parser.add_argument('--render', action='store_true', help='Enable rendering')
parser.add_argument('--ik_rl', action='store_true', help='Enable using RL based IK')
parser.add_argument('--ik', action='store_true', help='Enable using traditional IK')

args = parser.parse_args()

if args.ik and args.ik_rl:
    print("IK and IK RL cannot be enabled at the same time")
    exit(0)

RATE = 60
curr_target = np.array([0., 0., 0., 0., 0., 0., 0.])

class KukaJointController(Node):
    def __init__(self):
        super().__init__('kuka_joint_controller')

        self.env = KukaTennisEnv(proc_id=1)

        package_share_directory = get_package_share_directory('robot_control')
        logs_directory = os.path.join(package_share_directory, 'logs')

        best_model_path = os.path.join(logs_directory, 'best_model', 'best_model')
        best_model_ik1_path = os.path.join(logs_directory, 'best_model_ik1', 'best_model')




        # Dynamically calculate the path to logs
        #current_dir = os.path.dirname(__file__)
        #best_model_path = os.path.join(current_dir, 'logs', 'best_model', 'best_model')
        #best_model_ik1_path = os.path.join(current_dir, 'logs', 'best_model_ik1', 'best_model')

        # Load models dynamically
        # self.model = PPO.load(best_model_path)
        # self.model_ik = PPO.load(best_model_ik1_path)

        model = PPO.load(best_model_path)
        obs, _ = env.reset()
        
        if args.ik_rl:
            env_ik = KukaTennisEnvIK(proc_id=1)
            model_ik = PPO.load(best_model_ik1_path)
            obs_ik, _ = env_ik.reset()



        self.curr_target = np.array([0., 0., 0., 0., 0., 0., 0.])
        self.current_positions = np.zeros(7)
        self.current_velocities = np.zeros(7)
        self.joint_names = []

        self.subscription = self.create_subscription(
            Pose,
            'predicted_pose',
            self.target_pose_callback,
            10
        )

        self.joint_state_subscription = self.create_subscription(
            JointTrajectoryControllerState,
            '/lbr/PositionJointInterface_trajectory_controller/state',
            self.joint_state_callback,
            10
        )

        self.trajectory_pub = self.create_publisher(
            JointTrajectory,
            '/lbr/PositionJointInterface_trajectory_controller/command',
            10
        )

        self.timer = self.create_timer(1.0 / RATE, self.publish_trajectory_command)

        if args.ik:
            import moveit_commander
            self.group = moveit_commander.MoveGroupCommander('arm')
            self.group.set_max_velocity_scaling_factor(0.3)

    def target_pose_callback(self, msg):
        self.curr_target = np.array([
            msg.position.x,
            msg.position.y,
            msg.position.z,
            msg.orientation.x,
            msg.orientation.y,
            msg.orientation.z,
            msg.orientation.w
        ])
        self.get_logger().info(f"Target pose received: {self.curr_target}")
        self.env.set_target_pose(self.curr_target)

    def joint_state_callback(self, msg):
        self.current_positions = msg.actual.positions
        self.current_velocities = np.array(msg.actual.velocities)
        self.joint_names = msg.joint_names

    def restrict_range(self, val, min_val, max_val):
        return min(max(val, min_val), max_val)

    def publish_trajectory_command(self):
        if args.ik_rl:
            self.env_ik.reset_pose(self.current_positions)
            self.env_ik.set_target_pose(self.curr_target)
            for _ in range(50):
                action_ik, _ = self.model_ik.predict(self.obs_ik, deterministic=True)
                self.obs_ik, _, _, _, _ = self.env_ik.step(action_ik)
            action = self.env_ik.data.qpos[:7] - self.current_positions
        else:
            action = np.zeros(7)

        trajectory_msg = JointTrajectory()
        trajectory_point = JointTrajectoryPoint()

        if args.ik_rl:
            new_positions = list(np.array(self.current_positions) + np.array(action))
        else:
            new_positions = list(np.array(self.current_positions) + 0.2 * np.array(action))

        new_positions = [
            self.restrict_range(new_positions[i], -2.96 + (i % 2) * 0.87, 2.96 - (i % 2) * 0.87)
            for i in range(7)
        ]

        trajectory_point.positions = new_positions
        trajectory_point.time_from_start.sec = int(1 / RATE)
        trajectory_msg.points.append(trajectory_point)
        self.trajectory_pub.publish(trajectory_msg)

        if args.render:
            self.env.render()


def main(args=None):
    rclpy.init(args=args)
    node = KukaJointController()

    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    finally:
        node.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
