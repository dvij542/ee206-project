import cv2
from triangulation_utils import triangulate
from ultralytics import YOLO
#print('update')
def estimate_ball_3D_spatial_coords(model_path):
    # Initialize the YOLO model
    model = YOLO(model_path)

    def process_frame_with_yolo(frame):
        """
        Detects the ball in a single frame using YOLO.
        Returns the center (x, y) and radius of the detected ball.
        """
        results = model.predict(frame, conf=0.2, iou=0.4, verbose=False)

        # If there are no detections, return None
        if not results or results[0].boxes is None:
            return None, None

        # Find the best detection (highest confidence) for the ball
        best_detection = max(results[0].boxes, key=lambda box: box.conf.cpu().item())
        x, y, w, h = best_detection.xywh.cpu()[0]  # Center coordinates and dimensions
        radius = max(w, h) / 2  # Approximate radius as half the larger dimension

        return (int(x), int(y)), radius

    def helper(frame_cam1, frame_cam2, frame_cam3, frame_cam4):
        """
        Returns an estimate of the ball's spatial position and its associated reprojection error
        using YOLO detection on four camera frames.
        """
        # Detect the ball in each camera frame
        center1, radius1 = process_frame_with_yolo(frame_cam1)
        center2, radius2 = process_frame_with_yolo(frame_cam2)
        center3, radius3 = process_frame_with_yolo(frame_cam3)
        center4, radius4 = process_frame_with_yolo(frame_cam4)
        centers = [center1, center2, center3, center4]

        # Optional: Visualize detections (for debugging purposes)
        for frame, center, radius in zip(
            [frame_cam1, frame_cam2, frame_cam3, frame_cam4], 
            [center1, center2, center3, center4], 
            [radius1, radius2, radius3, radius4]
        ):
            if center and radius:
                cv2.circle(frame, center, int(radius), (0, 0, 255), 2)
                cv2.imshow("Detected Frame", frame)
                cv2.waitKey(1)

        # Perform triangulation to estimate 3D position
        ball_spatial_coords, error = triangulate(centers)
        print("Triangulation estimate:", ball_spatial_coords, error)

        return ball_spatial_coords, error

    return helper

# Initialize the helper function
estimate_ball_3D_spatial_coords = estimate_ball_3D_spatial_coords(model_path="/home/dvij/ee206-project/ping-pong-robot/ppr_ws/src/camera_feed/camera_feed/runs/detect/train4/weights/best.pt")
