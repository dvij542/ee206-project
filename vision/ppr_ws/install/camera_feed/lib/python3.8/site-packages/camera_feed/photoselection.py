import cv2
import os
import json
import numpy as np
import matplotlib.pyplot as plt
from tqdm import tqdm

def clear_directories(directories):
    """
    Clears all files from the provided directories if user confirms.
    
    Args:
        directories (list): List of directories to be cleared.
    """
    for directory in directories:
        if os.path.exists(directory):
            confirm = input(f"Do you want to remove all existing files in {directory}? (yes/no): ").strip().lower()
            if confirm == "yes":
                print(f"Clearing files in {directory}...")
                # Remove all files in the directory
                for file_name in os.listdir(directory):
                    file_path = os.path.join(directory, file_name)
                    if os.path.isfile(file_path):
                        os.remove(file_path)
                print(f"Files cleared in {directory}.")
            else:
                print(f"Files not cleared in {directory}.")
        else:
            print(f"Directory {directory} does not exist. Skipping clearance.")

def detect_checkerboard(image, checkerboard_size=(7, 8), adaptive_thresh=True, normalize=True):
    """
    Detect checkerboard with multiple preprocessing techniques.
    
    Args:
        image (numpy.ndarray): Input image
        checkerboard_size (tuple): Number of inner corners (rows, columns)
        adaptive_thresh (bool): Use adaptive thresholding
        normalize (bool): Normalize image before detection
    
    Returns:
        tuple: (success, corners, processed_image)
    """
    # Convert to grayscale
    if len(image.shape) == 3:
        gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    else:
        gray = image.copy()
    
    # Optional normalization
    if normalize:
        gray = cv2.equalizeHist(gray)
    
    # Apply Gaussian blur to reduce noise
    blurred = cv2.GaussianBlur(gray, (5, 5), 0)

    # Multiple detection strategies
    detection_strategies = [
        # Standard detection
        (cv2.findChessboardCorners, 
         (blurred, checkerboard_size, cv2.CALIB_CB_ADAPTIVE_THRESH | cv2.CALIB_CB_NORMALIZE_IMAGE)),
        
        # Alternate detection with different flags
        (cv2.findChessboardCorners, 
         (blurred, checkerboard_size, cv2.CALIB_CB_FAST_CHECK)),
        
        # Detection after more aggressive preprocessing
        (cv2.findChessboardCorners, 
         (cv2.Canny(blurred, 100, 200), checkerboard_size, 
          cv2.CALIB_CB_ADAPTIVE_THRESH | cv2.CALIB_CB_NORMALIZE_IMAGE))
    ]
    
    for finder, args in detection_strategies:
        try:
            ret, corners = finder(*args)
            if ret:
                # Refine corner detection
                criteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 30, 0.001)
                corners_refined = cv2.cornerSubPix(gray, corners, (11, 11), (-1, -1), criteria)
                return True, corners_refined, gray
        except Exception as e:
            print(f"Detection strategy failed: {e}")
    
    return False, None, gray

def get_last_image_index(output_dir):
    """
    Get the highest index from existing files in the output directory.
    
    Args:
        output_dir (str): Output directory to check
    
    Returns:
        int: The highest index in the directory
    """
    existing_files = os.listdir(output_dir)
    highest_index = -1
    
    for file in existing_files:
        try:
            if file.lower().endswith(('.jpg', '.jpeg')):  # Check for valid image extension
                file_name = file.split('.')[0]
                if "_none" in file_name:
                    file_name = file_name.replace("_none", "")  # Remove the '_none' part for proper indexing
                index = int(file_name)
                highest_index = max(highest_index, index)
        except ValueError:
            continue  # Skip files that cannot be converted to integers
    
    return highest_index

def process_checkerboard_images(
    input_dir, 
    output_dir, 
    checkerboard_size=(6, 7), 
    square_size_mm=59,
    display_results=True
):
    """
    Process images for checkerboard detection with improved robustness.
    
    Args:
        input_dir (str): Input image directory
        output_dir (str): Output directory for processed images
        checkerboard_size (tuple): Checkerboard inner corner dimensions
        square_size_mm (float): Size of each square in millimeters
        display_results (bool): Show matplotlib visualization for the first image
    """
    # Create the output directory if it doesn't exist
    os.makedirs(output_dir, exist_ok=True)

    valid_images = []
    invalid_images = []
    
    # Get image files
    image_files = sorted([f for f in os.listdir(input_dir) if f.lower().endswith(('.png', '.jpg', '.jpeg'))])

    if not image_files:  # Skip if no valid images in the directory
        print(f"No valid images found in {input_dir}. Skipping this directory.")
        return  # Skip processing this directory

    # Get the last image index in the output directory to avoid overwriting
    last_index = get_last_image_index(output_dir)
    current_index = last_index + 1  # Start from the next index
    
    first_image_processed = False  # Flag to control displaying the first image
    
    for image_file in tqdm(image_files):
        img_path = os.path.join(input_dir, image_file)
        img = cv2.imread(img_path)
        
        if img is None:
            print(f"Skipping invalid image: {image_file}")
            invalid_images.append(image_file)
            continue
        
        # Detect checkerboard
        success, corners, processed_img = detect_checkerboard(img, checkerboard_size)
        
        if success:
            valid_images.append(image_file)
            
            # Save the original image (without corners drawn)
            new_image_name = f"{current_index:02d}.jpg"  # Use current index for the file name
            cv2.imwrite(os.path.join(output_dir, new_image_name), img)
            current_index += 1  # Increment the index for the next image
            
            # Display first image with corners detected, then skip for others
            if display_results and not first_image_processed:
                plt.figure(figsize=(10, 5))
                plt.subplot(121)
                plt.title(f"Original: {image_file}")
                plt.imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))
                plt.axis('off')
                
                plt.subplot(122)
                plt.title(f"Corners Detected: {image_file}")
                img_with_corners = img.copy()
                cv2.drawChessboardCorners(img_with_corners, checkerboard_size, corners, success)
                plt.imshow(cv2.cvtColor(img_with_corners, cv2.COLOR_BGR2RGB))
                plt.axis('off')
                
                plt.tight_layout()
                plt.show()
                first_image_processed = True  # Set flag after displaying first image
        else:
            print(f"Checkerboard not detected in: {image_file}")
            invalid_images.append(image_file)
            new_image_name = f"{current_index:02d}_none.jpg"  # Naming format for failed images: 00_none, 01_none, etc.
            cv2.imwrite(os.path.join(output_dir, new_image_name), img)
            current_index += 1  # Increment the index for the next image

    # Save metadata
    metadata = {
        "valid_images": valid_images, 
        "invalid_images": invalid_images,
        "total_images": len(image_files),
        "detection_rate": (len(valid_images) / len(image_files) * 100) if image_files else 0
    }
    
    with open(os.path.join(output_dir, "image_metadata.json"), "w") as f:
        json.dump(metadata, f, indent=4)
    
    print(f"Processing complete. Detection rate: {metadata['detection_rate']:.2f}%")



# List of camera folders to process for testing
camera_folders = ["camera_0", "camera_1", "camera_2", "camera_3"]

# Example usage for each camera folder
output_directories = [f"./calibration_images/{camera_folder}_processed" for camera_folder in camera_folders]
clear_directories(output_directories)

for camera_folder in camera_folders:
    input_directory = f"./calibration_images/{camera_folder}"
    output_directory = f"./calibration_images/{camera_folder}_processed"
    
    checkerboard_dims = (6, 7)
    square_size_mm = 59

    process_checkerboard_images(
        input_directory, 
        output_directory, 
        checkerboard_size=checkerboard_dims, 
        square_size_mm=square_size_mm,
        display_results=True
    )

