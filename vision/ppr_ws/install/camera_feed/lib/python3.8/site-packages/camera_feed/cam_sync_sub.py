import rclpy
import message_filters
from rclpy.node import Node

import cv2
from sensor_msgs.msg import Image
from ppr_interfaces.msg import Scene
from cv_bridge import CvBridge # Package to convert between ROS and OpenCV Images


class ImageSubscriber(Node):

    def __init__(self):
        super().__init__(f'camera_subscriber')
        self.br = CvBridge()

        queue_size = 10
        tss = message_filters.ApproximateTimeSynchronizer(
            [message_filters.Subscriber(self, Image, f"cam_{i}") for i in range(1, 5)],
            queue_size,
            0.05, # defines the delay (in seconds) with which messages can be synchronized
            ) # NOTE: this delay can cause us to publish at a very slow rate! if frames aren't synchronized
        tss.registerCallback(self.listener_callback)
        self.publisher_ = self.create_publisher(Scene, 'synchronized_cam_feed', 10) 
        self.get_logger().info('Initialized.')

    def listener_callback(self, *frames):
        # self.get_logger().info('Receiving grouped frame video frame.')
        # f1 = self.br.imgmsg_to_cv2(frames[0])
        # cv2.imshow("camera1", f1)
        # f2 = self.br.imgmsg_to_cv2(frames[1])
        # cv2.imshow("camera2", f2)
        # f3 = self.br.imgmsg_to_cv2(frames[2])
        # cv2.imshow("camera3", f3)
        # f4 = self.br.imgmsg_to_cv2(frames[3])
        # cv2.imshow("camera4", f4)   
        # cv2.waitKey(1)

        scene = Scene()
        scene.frames = frames

        self.publisher_.publish(scene) 



def main(args=None):
    rclpy.init(args=args)

    image_subscriber = ImageSubscriber()

    rclpy.spin(image_subscriber)

    # Destroy the node explicitly
    # (optional - otherwise it will be done automatically
    # when the garbage collector destroys the node object)
    image_subscriber.destroy_node()
    rclpy.shutdown()


if __name__ == '__main__':
    main()
