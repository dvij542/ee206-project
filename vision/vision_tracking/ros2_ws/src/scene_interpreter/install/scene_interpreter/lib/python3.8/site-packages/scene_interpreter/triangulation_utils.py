import numpy as np
import sys
import os

sys.path.insert(0, "/home/dvij/ee206-project/ping-pong-robot/ppr_ws/src/camera_feed/camera_feed")

# Import the functions from 'test.py'
from test import load_calibration_results, load_RTG

# Call the function to get the necessary matrices
mtx_list, dist_list, P_list, R_list = load_calibration_results("/home/dvij/ee206-project/ping-pong-robot/ppr_ws/src/camera_feed/camera_feed/calibration_results.npz")
P0 = P_list[0]
P1 = P_list[1]
P2 = P_list[2]
P3 = P_list[3]
R, T, g_spatial_cam3 = load_RTG("/home/dvij/ee206-project/ping-pong-robot/ppr_ws/src/camera_feed/camera_feed/calibration/RTG.npz")

def normalize_homogeneous_coordinates(x):
    """
    Normalize homogeneous coordinates: [X Y Z W] -> [X/W Y/W Z/W 1].
    """
    return x / x[3]

def homogeneous_to_pixel_coordinates(x):
    """
    Convert homogeneous coordinates to pixel coordinates: [X Y Z 1] -> [X/Z Y/Z 1].
    """
    return x[:3] / x[2]

def DLT(active_pairs):
    """
    Direct Linear Transform for triangulating 3D points.

    Args:
        active_pairs: List of tuples [(P, center), ...], where P is the projection matrix and center is the detected point.

    Returns:
        Homogeneous coordinates of the triangulated 3D point.
    """
    A_blocks = []
    for P, center in active_pairs:
        A_blocks.append(np.array([
            center[1] * P[2, :] - P[1, :],
            center[0] * P[2, :] - P[0, :],
        ]))

    A = np.vstack(A_blocks).reshape((2 * len(active_pairs), 4))
    U, s, VT = np.linalg.svd(A, full_matrices=False)
    homog_ball_coords = VT[-1]  # Corresponds to the smallest singular value

    return normalize_homogeneous_coordinates(homog_ball_coords)

def reprojection_error(active_pairs, ball_cam_coords):
    """
    Calculate the reprojection error (in pixels).

    Args:
        active_pairs: List of tuples [(P, center), ...], where P is the projection matrix and center is the detected point.
        ball_cam_coords: Homogeneous coordinates of the estimated 3D point.

    Returns:
        Average reprojection error across all active pairs.
    """
    total_deviation = 0
    for P, center in active_pairs:
        estimated_center = homogeneous_to_pixel_coordinates(P @ ball_cam_coords)[:2]
        total_deviation += np.linalg.norm(estimated_center - center)

    return total_deviation / len(active_pairs)

def triangulate(centers):
    """
    Triangulate the 3D spatial coordinates of a point using DLT.

    Args:
        centers: List of (x, y) tuples representing detected points from different cameras.

    Returns:
        ball_spatial_coords: Estimated 3D coordinates in the spatial frame.
        error: Reprojection error.
    """
    if len(centers) < 4:
        centers += [None] * (4 - len(centers))  # Ensure the list has exactly 4 elements

    pairs = [(P0, centers[0]), (P1, centers[1]), (P2, centers[2]), (P3, centers[3])]
    active_pairs = [pair for pair in pairs if pair[1] is not None]

    if len(active_pairs) < 2:
        print("Error: Not enough valid centers for triangulation.")
        return None, float('inf')

    # Perform Direct Linear Transform to find the 3D point
    ball_cam_coords = DLT(active_pairs)

    # Calculate reprojection error
    error = reprojection_error(active_pairs, ball_cam_coords)

    # Transform to spatial frame
    ball_spatial_coords = g_spatial_cam3 @ ball_cam_coords

    return ball_spatial_coords, error


