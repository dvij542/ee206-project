import numpy as np

def normalize_homogeneous_coordinates(x):
    """
    [X Y Z W] -> [X/W Y/W Z/W 1]
    """
    return x / x[3]


def homogeneous_to_pixel_coordinates(x):
    """
    [X Y Z 1] -> [X/Z Y/Z 1]
    """
    return x[:3] / x[2]


def DLT(active_pairs):
    """
    active_pairs: a list of projection matrix, center pairs
    """

    A_blocks = []
    for P, center in active_pairs:
        A_blocks.append(np.array([
            center[1]*P[2, :] - P[1, :],
            P[0, :] - center[0]*P[2, :],
        ]))

    A = np.vstack(A_blocks).reshape((2 * len(active_pairs), 4))
    # TODO: We can just find the SVD of A. Don't need to find the SVD of A^T @ A. At least that's what I think ...
    B = A.transpose() @ A

    U, s, VT = np.linalg.svd(B, full_matrices=False)
    homog_ball_coords = VT[3, 0:4]

    return normalize_homogeneous_coordinates(homog_ball_coords)


def reprojection_error(active_pairs, ball_cam_coords):
    """
    Returns the reprojection error (pixels) of the ball's estimated homogenous coordinates.
    """
    center_deviation = 0
    for P, center in active_pairs:
        estimated_center = homogeneous_to_pixel_coordinates(
            P @ ball_cam_coords)[:2]
        center_deviation += np.abs(np.sum(estimated_center - center))
    return center_deviation / len(active_pairs)


def triangulate(centers):
    """
    Returns the estimated ball's homogeneous coordinates in the spatial frame.
    """

    pairs = [(P1, centers[0]), (P2, centers[1]), (P3, centers[2]), (P4, centers[3])]
    active_pairs = [pair for pair in pairs if pair[1] != None]

    if len(active_pairs) < 2:
        return None, float('inf')

    ball_cam_coords = DLT(active_pairs)
    error = reprojection_error(active_pairs, ball_cam_coords)
    ball_spatial_coords = g_spatial_cam4 @ ball_cam_coords
    return ball_spatial_coords, error

P1 = np.array([[-1.06029099e+03, -4.62349200e+02,  1.33256455e+03,
        -1.48424272e+05],
       [ 4.06983331e+02,  1.26744604e+03,  1.04442921e+03,
        -1.08653915e+05],
       [-8.05203562e-01,  5.84078012e-01,  1.02469998e-01,
         1.68040390e+02]])
P2 = np.array([[-1.45401309e+03,  7.62650389e+02,  2.00387344e+02,
        -6.47350977e+04],
       [ 3.53621111e+02,  9.08709890e+02,  9.55984593e+02,
        -1.45014771e+05],
       [-4.75319464e-02,  9.40286029e-01, -3.37050289e-01,
         2.98479916e+02]])
P3 = np.array([[ 7.45218672e+02,  1.40786439e+03, -8.88195913e+02,
         5.19172944e+05],
       [-5.15396574e+02,  1.51151450e+03,  1.52387331e+03,
        -2.85307056e+05],
       [ 8.81842402e-01,  2.79809989e-01,  3.79552827e-01,
         2.21982583e+02]])
P4 = np.array([[1.73385289e+03, 0.00000000e+00, 7.19925547e+02, 0.00000000e+00],
       [0.00000000e+00, 1.88385155e+03, 5.25249628e+02, 0.00000000e+00],
       [0.00000000e+00, 0.00000000e+00, 1.00000000e+00, 0.00000000e+00]])

R = np.array([[-0.60184858,  0.4579465 , -0.65426546],
       [-0.79742926, -0.3000699 ,  0.52351182],
       [ 0.04341504,  0.83680527,  0.54577658]])
T = np.array([  57.69871518,  -40.55536   , -286.55454885]).reshape((3, 1))
g_spatial_cam4 = np.concatenate(
    [np.concatenate([R, T], axis=1), np.array([0, 0, 0, 1]).reshape((1, 4))], axis=0)

# P1 = np.array([[-3.53267356e+02,  3.45862696e+01,  7.81242988e+02,
#         -1.10611295e+05],
#        [ 1.03153653e+02,  2.53989139e+02,  5.23047906e+02,
#         -5.47719881e+04],
#        [-2.67459774e-01,  5.60715392e-01,  7.83622051e-01,
#         -1.43048023e+02]])
# P2 = np.array([[-1.44579750e+03,  8.14164090e+02,  5.76825645e+02,
#         -9.86451839e+04],
#        [ 4.13496680e+02,  3.56925513e+02,  1.19597092e+03,
#          1.91599615e+04],
#        [ 9.26874394e-02,  9.89792129e-01,  1.08261630e-01,
#          2.25864329e+02]])
# P3 = np.array([[ 8.07959933e+02,  1.93998035e+03, -7.87389664e+02,
#          5.63978571e+05],
#        [-8.50098336e+02,  2.30042734e+03,  4.30483782e+03,
#         -8.72639022e+05],
#        [ 9.59207155e-01,  8.12109854e-02,  2.70788495e-01,
#          4.51613080e+02]])
# P4 = np.array([[1.12661895e+03, 0.00000000e+00, 7.19963610e+02, 0.00000000e+00],
#        [0.00000000e+00, 7.60267452e+02, 5.29468557e+02, 0.00000000e+00],
#        [0.00000000e+00, 0.00000000e+00, 1.00000000e+00, 0.00000000e+00]])

# R = np.array([[-0.5637285,  0.68670402, -0.45896379],
#               [-0.82583481, -0.45893287,  0.32768504],
#               [0.01438907,  0.56375367,  0.82581763]])
# T = np.array([71.54635766,  -73.21437911, -222.2386006]).reshape((3, 1))
# g_spatial_cam4 = np.concatenate([np.concatenate([R, T], axis=1), np.array([0, 0, 0, 1]).reshape((1, 4))], axis=0)