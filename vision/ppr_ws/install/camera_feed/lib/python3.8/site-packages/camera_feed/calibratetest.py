import cv2
import numpy as np
import glob
import os
import json
from tqdm import tqdm

def calibrate_camera(image_paths, checkerboard_size=(6, 7), square_size_mm=59):
    """
    Calibrate a camera using checkerboard images.

    Args:
        image_paths (list): List of paths to checkerboard images.
        checkerboard_size (tuple): Number of inner corners (rows, columns).
        square_size_mm (float): Size of each square in millimeters.
    
    Returns:
        tuple: Camera matrix, distortion coefficients, rotation vectors, and translation vectors.
    """
    obj_points = []  # 3D points in real world space
    img_points = []  # 2D points in image plane

    # Prepare object points, e.g., (0,0,0), (1,0,0), (2,0,0), ..., (6,5,0)
    objp = np.zeros((checkerboard_size[0] * checkerboard_size[1], 3), np.float32)
    objp[:, :2] = np.mgrid[0:checkerboard_size[0], 0:checkerboard_size[1]].T.reshape(-1, 2)
    objp *= square_size_mm  # Convert to mm

    for image_path in tqdm(image_paths, desc="Calibrating camera"):
        img = cv2.imread(image_path)
        gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

        # Find checkerboard corners
        ret, corners = cv2.findChessboardCorners(gray, checkerboard_size, None)
        if ret:
            img_points.append(corners)
            obj_points.append(objp)

    # Camera calibration
    ret, mtx, dist, rvecs, tvecs = cv2.calibrateCamera(obj_points, img_points, gray.shape[::-1], None, None)
    
    if ret:
        print(f"Camera Matrix:\n{mtx}")
        print(f"Distortion Coefficients:\n{dist}")
        return mtx, dist, rvecs, tvecs
    else:
        print("Calibration failed.")
        return None, None, None, None

def compute_relative_pose(camera_rvecs, camera_tvecs, base_camera_rvec, base_camera_tvec):
    """
    Compute the relative pose (rotation and translation) between two cameras.

    Args:
        camera_rvecs (array): Rotation vector of the camera.
        camera_tvecs (array): Translation vector of the camera.
        base_camera_rvec (array): Rotation vector of the base camera.
        base_camera_tvec (array): Translation vector of the base camera.

    Returns:
        tuple: Relative rotation matrix and translation vector.
    """
    R1, _ = cv2.Rodrigues(camera_rvecs)
    T1 = camera_tvecs

    R2, _ = cv2.Rodrigues(base_camera_rvec)
    T2 = base_camera_tvec

    # Relative rotation: R_rel = R2^T * R1
    R_rel = np.dot(R2.T, R1)

    # Relative translation: T_rel = T2 - R_rel * T1
    T_rel = T2 - np.dot(R_rel, T1)

    return R_rel, T_rel

def transform_point(point, R_rel, T_rel):
    """
    Transform a 3D point from one camera frame to another using the relative pose.

    Args:
        point (list): 3D point in camera frame.
        R_rel (array): Relative rotation matrix.
        T_rel (array): Relative translation vector.

    Returns:
        array: Transformed point in the target camera frame.
    """
    point = np.array(point).reshape(3, 1)
    transformed_point = np.dot(R_rel, point) + T_rel
    return transformed_point

def process_camera_images(input_dir, checkerboard_size=(6, 7), square_size_mm=59):
    """
    Process the camera images for calibration.

    Args:
        input_dir (str): Path to the directory containing checkerboard images.
        checkerboard_size (tuple): Number of inner corners (rows, columns).
        square_size_mm (float): Size of each square in millimeters.

    Returns:
        tuple: Camera matrix, distortion coefficients, rotation vectors, and translation vectors.
    """
    image_paths = glob.glob(os.path.join(input_dir, "*.jpg"))
    camera_matrix, dist_coeffs, rvecs, tvecs = calibrate_camera(image_paths, checkerboard_size, square_size_mm)
    return camera_matrix, dist_coeffs, rvecs, tvecs

def main():
    # Directories for each camera's checkerboard images
    camera_folders = ["camera_0", "camera_1", "camera_2", "camera_3"]
    
    # Store calibration results
    calibration_results = {}

    for camera_folder in camera_folders:
        input_directory = f"./calibration_images/{camera_folder}"
        print(f"Processing {camera_folder}...")
        camera_matrix, dist_coeffs, rvecs, tvecs = process_camera_images(input_directory)
        calibration_results[camera_folder] = {
            "camera_matrix": camera_matrix,
            "dist_coeffs": dist_coeffs,
            "rvecs": rvecs,
            "tvecs": tvecs
        }

    # Compute relative poses (Camera 0 to Camera 3 as an example)
    base_camera_folder = "camera_3"
    base_rvec = calibration_results[base_camera_folder]["rvecs"][0]
    base_tvec = calibration_results[base_camera_folder]["tvecs"][0]

    relative_poses = {}
    for camera_folder in camera_folders:
        if camera_folder == base_camera_folder:
            continue
        rvec = calibration_results[camera_folder]["rvecs"][0]
        tvec = calibration_results[camera_folder]["tvecs"][0]
        R_rel, T_rel = compute_relative_pose(rvec, tvec, base_rvec, base_tvec)
        relative_poses[camera_folder] = {"R_rel": R_rel, "T_rel": T_rel}
        print(f"Relative pose from {camera_folder} to {base_camera_folder}:")
        print(f"Rotation Matrix:\n{R_rel}")
        print(f"Translation Vector:\n{T_rel}")

    # Example of transforming a point from Camera 0 to Camera 3
    point_in_camera_0 = [100, 150, 200]  # Replace with actual point coordinates
    R_rel, T_rel = relative_poses["camera_0"]["R_rel"], relative_poses["camera_0"]["T_rel"]
    point_in_camera_3 = transform_point(point_in_camera_0, R_rel, T_rel)
    print(f"Transformed point from Camera 0 to Camera 3: {point_in_camera_3.flatten()}")

    # Save calibration results to a JSON file
    with open("calibration_results.json", "w") as f:
        json.dump(calibration_results, f, indent=4)

if __name__ == "__main__":
    main()
