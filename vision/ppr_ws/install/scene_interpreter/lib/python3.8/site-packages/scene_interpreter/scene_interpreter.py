from .ball_state_estimator import estimate_ball_3D_spatial_coords

import rclpy
from rclpy.node import Node
from geometry_msgs.msg import Point
from ppr_interfaces.msg import Scene

from cv_bridge import CvBridge 
import time

class SceneInterpreter(Node):

    def __init__(self):
        super().__init__(f'scene_interpreter')

        self.subscription = self.create_subscription(
            Scene, 
            "synchronized_cam_feed", 
            self.listener_callback, 
            10)
        self.subscription # prevent unused variable warning
        self.sci_publisher = self.create_publisher(Scene, "scene_interpretation", 10)
        self.bse_publisher = self.create_publisher(Point, "ball_state_estimate", 10)
        self.br = CvBridge()
        self.get_logger().info('Initialized.')

    def listener_callback(self, scene):
        # TODO: if this method is too slow, can make some of the below calls into async service calls
        
        start = time.time()
        frames = [self.br.imgmsg_to_cv2(frame) for frame in scene.frames]
        ball_spatial_coords, error = estimate_ball_3D_spatial_coords(*frames)
        if ball_spatial_coords is None:
            return
        
        p = Point()
        p.x, p.y, p.z = ball_spatial_coords[:3]
        self.bse_publisher.publish(p)
        scene.ball_spatial_coords = p
        self.sci_publisher.publish(scene)
        self.get_logger().info(f"Time to triangulate: {time.time() - start}.")
        
        # human pose estimate

def main(args=None):
    rclpy.init(args=args)

    sci = SceneInterpreter()
    rclpy.spin(sci)
    sci.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()