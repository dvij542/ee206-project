import time
import os
from PIL import Image as PILImage
import cv2
import numpy as np
import gi
from ultralytics import YOLO
import threading
import signal
import queue
from typing import Dict, Optional
gi.require_version('Aravis', '0.8')
from gi.repository import Aravis

# Global shutdown event
shutdown_event = threading.Event()
# Global frame queues for each camera
frame_queues: Dict[int, queue.Queue] = {}

def signal_handler(signum, frame):
    print("\nSignal received, initiating shutdown...")
    shutdown_event.set()

# Register signal handlers
signal.signal(signal.SIGINT, signal_handler)  # Ctrl+C
signal.signal(signal.SIGTERM, signal_handler)  # Termination request

def wait_until_next_start_point():
    start_point = 5
    current_time = time.time()
    next_start_time = (current_time // start_point + 1) * start_point
    time.sleep(next_start_time - current_time)

class PingPongTracker:
    def __init__(self, cam_num=0, model_path="best.pt"):
        self.cam_num = cam_num
        self.running = True
        frame_queues[cam_num] = queue.Queue(maxsize=10)

        # Verify model path
        if not os.path.exists(model_path):
            print(f"WARNING: Model path {model_path} does not exist!")
            print("Available files:", os.listdir(os.path.dirname(model_path) or '.'))

        # Initialize YOLO model with error handling
        try:
            self.model = YOLO(model_path)
            print(f"Camera {cam_num} - Model Classes:", self.model.names)
        except Exception as e:
            print(f"Camera {cam_num} - Error loading YOLO model: {e}")
            self.model = None

        # Camera settings
        EXPOSURE_TIME = 100000
        cameras = {
            "Daheng Imaging-2BA200003814-FDN21120585": 0,
            "Daheng Imaging-2BA200003827-FDN21120598": 1,
            "Daheng Imaging-2BA200003813-FDN21120584": 2,
            "Daheng Imaging-2BA200003815-FDN21120586": 3,
        }

        camera_id = next((key for key, value in cameras.items() if value == cam_num), None)
        assert camera_id is not None, f"Camera ID not found for camera {cam_num}"

        # Set up camera
        Aravis.enable_interface("Fake")
        self.cam = Aravis.Camera.new(camera_id)
        self.cam.set_string('AcquisitionFrameRateMode', 'On')
        self.cam.set_string('BalanceWhiteAuto', 'Continuous')
        self.cam.set_exposure_time(EXPOSURE_TIME)
        self.cam.get_device().set_float_feature_value('AcquisitionFrameRate', 120.0)

        device = self.cam.get_device()
        device.set_string_feature_value("AcquisitionMode", "Continuous")
        payload = self.cam.get_payload()
        self.stream = self.cam.create_stream(None, None)

        for i in range(5):
            self.stream.push_buffer(Aravis.Buffer.new_allocate(payload))

        [_, _, self.width, self.height] = self.cam.get_region()

        # Initialize tracker
        self.tracker = None
        self.track_history = {}

    def process_frame(self, frame):
        if shutdown_event.is_set():
            return None

        # Create a copy for annotation
        annotated_frame = frame.copy()
        detected_balls = []

        # Try YOLO detection first
        if self.model:
            try:
                results = self.model.track(
                    frame,
                    tracker="bytetrack.yaml",
                    persist=True,
                    conf=0.05,
                    iou=0.5,
                    verbose=False
                )

                if results and len(results) > 0 and results[0].boxes is not None:
                    for box in results[0].boxes:
                        x, y, w, h = box.xywh.cpu()[0]
                        conf = box.conf.cpu()[0]

                        detected_balls.append({
                            'method': 'YOLO',
                            'x': float(x),
                            'y': float(y),
                            'width': float(w),
                            'height': float(h),
                            'confidence': float(conf)
                        })

                        cv2.rectangle(annotated_frame,
                                      (int(x - w/2), int(y - h/2)),
                                      (int(x + w/2), int(y + h/2)),
                                      (0, 255, 0), 2)

                        cv2.putText(annotated_frame,
                                    f"Conf: {conf:.2f}",
                                    (int(x - w/2), int(y - h/2) - 10),
                                    cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 0, 255), 2)

            except Exception as e:
                print(f"Camera {self.cam_num} - YOLO detection error: {e}")

        return annotated_frame, detected_balls

    def run(self):
        try:
            wait_until_next_start_point()
            print(f"Starting acquisition for Camera {self.cam_num}")
            self.cam.start_acquisition()

            while not shutdown_event.is_set():
                try:
                    buffer = self.stream.pop_buffer()
                    if buffer:
                        data_from_buffer = buffer.get_data()
                        image_pil = PILImage.frombytes('L', (self.width, self.height), data_from_buffer)
                        image_rgb = cv2.cvtColor(np.array(image_pil), cv2.COLOR_BAYER_RG2RGB)

                        tracked_frame, detected_balls = self.process_frame(image_rgb)
                        if tracked_frame is None:  # Check for shutdown
                            break

                        # Instead of showing the frame directly, put it in the queue
                        try:
                            frame_queues[self.cam_num].put_nowait((tracked_frame, detected_balls))
                        except queue.Full:
                            # If queue is full, remove oldest frame
                            try:
                                frame_queues[self.cam_num].get_nowait()
                                frame_queues[self.cam_num].put_nowait((tracked_frame, detected_balls))
                            except queue.Empty:
                                pass

                        self.stream.push_buffer(buffer)

                except Exception as e:
                    print(f"Error in camera {self.cam_num} loop: {e}")
                    if not shutdown_event.is_set():
                        shutdown_event.set()
                    break

        except Exception as e:
            print(f"Fatal error in camera {self.cam_num}: {e}")
            shutdown_event.set()
        finally:
            print(f"Cleaning up camera {self.cam_num}")
            try:
                self.cam.stop_acquisition()
            except Exception as e:
                print(f"Error stopping acquisition for camera {self.cam_num}: {e}")

def display_thread(camera_numbers, output_width=1280, output_height=720):
    """Separate thread for handling all window displays."""
    while not shutdown_event.is_set():
        frames = []
        for cam_num in camera_numbers:
            try:
                frame, detected_balls = frame_queues[cam_num].get_nowait()

                # Print detection results
                print(f"Camera {cam_num} - Frame Detection Summary:")
                print(f"Total Balls Detected: {len(detected_balls)}")
                for i, ball in enumerate(detected_balls, 1):
                    print(f"  - Camera Frame Coordinate for Ball {i}: (x: {ball['x']:.2f}, y: {ball['y']:.2f})")
                    if ball['confidence'] is not None:
                        print(f"  - Confidence: {ball['confidence']:.2f}")
                    print()

                frames.append(frame)

            except queue.Empty:
                # Append a black frame if no new frame is available
                frames.append(np.zeros((output_height, output_width, 3), dtype=np.uint8))

        if frames:
            # Combine frames horizontally
            combined_frame = np.hstack(frames)

            # Resize the combined frame to fit the output window size
            resized_frame = cv2.resize(combined_frame, (output_width, output_height))

            # Display resized frame
            cv2.imshow("Multi-Camera Tracking", resized_frame)

        if cv2.waitKey(1) & 0xFF == ord('q'):
            print("'q' pressed in display window")
            shutdown_event.set()
            break

    cv2.destroyAllWindows()

class MultiCameraSystem:
    def __init__(self, camera_numbers, model_path):
        self.camera_numbers = camera_numbers
        self.trackers = []
        self.threads = []
        self.active_cameras = []

        for cam_num in camera_numbers:
            try:
                tracker = PingPongTracker(cam_num=cam_num, model_path=model_path)
                self.trackers.append(tracker)
                self.threads.append(threading.Thread(target=tracker.run))
                self.active_cameras.append(cam_num)
            except Exception as e:
                print(f"Camera {cam_num} initialization failed: {e}")

        if not self.active_cameras:
            raise RuntimeError("No functional cameras available!")

        # Add display thread
        self.display_thread = threading.Thread(target=display_thread, args=(self.active_cameras,))
        self.threads.append(self.display_thread)

    def start(self):
        print(f"Starting cameras: {self.active_cameras}")
        for thread in self.threads:
            thread.start()

    def stop(self):
        print("Stopping all cameras...")
        shutdown_event.set()

        for thread in self.threads:
            if thread.is_alive():
                thread.join(timeout=5.0)

        cv2.destroyAllWindows()

def main():
    possible_paths = [
        "best.pt",
        "runs/detect/train/weights/best.pt",
        "./best.pt",
        "../best.pt"
    ]

    model_path = None
    for path in possible_paths:
        if os.path.exists(path):
            model_path = path
            break

    if not model_path:
        print("ERROR: Could not find YOLO model file!")
        return

    # Initialize multi-camera system with up to four cameras (0-indexed)
    system = MultiCameraSystem(camera_numbers=[0, 1, 2, 3], model_path= "runs/detect/train4/weights/best.pt")

    try:
        system.start()

        # Main loop
        while not shutdown_event.is_set():
            time.sleep(0.1)

    except KeyboardInterrupt:
        print("\nReceived keyboard interrupt, shutting down...")
    finally:
        print("Initiating shutdown sequence...")
        system.stop()
        print("Shutdown complete.")

if __name__ == '__main__':
    main()
