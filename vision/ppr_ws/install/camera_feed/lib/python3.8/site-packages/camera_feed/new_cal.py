#!/usr/bin/env python
import cv2 as cv
import numpy as np
import os
from utilscopy import calibrate_camera, stereo_calibrate

def load_image_paths(base_dir, camera_pairs):
    """
    Load image paths for the given camera pairs based on their filenames.
    Both cameras in a pair share the same directory, and the images are named in a specific format.

    Parameters:
    - base_dir: The base directory where the images are stored.
    - camera_pairs: List of camera pair tuples [(camera_0, camera_3), (camera_1, 3), (camera_2, 3)].

    Returns:
    - List of image paths for each camera pair.
    """
    image_paths = {pair: [] for pair in camera_pairs}

    # Print the list of camera pairs to verify they are being passed correctly
    print(f"Camera pairs: {camera_pairs}")

    for pair in camera_pairs:
        cam_a, cam_b = pair
        
        # Print the camera pair being processed
        print(f"Processing pair: {pair}")

        # Check the common directory for both cam_a and cam_b
        cam_dir = os.path.join(base_dir, f'cam_{cam_a}_cam_{cam_b}')  # Format folder name like cam_0_cam_3
        
        # Print the directory path to debug
        print(f"Checking directory: {cam_dir}")

        # Check if the directory exists
        if not os.path.isdir(cam_dir):
            print(f"Directory {cam_dir} not found!")
            continue

        # Load images from the directory for each camera in the pair
        cam_a_images = {int(f.split('_')[2].split('.')[0]) for f in os.listdir(cam_dir) if f.startswith(f'cam_{cam_a}_') and f.endswith('.jpg')}
        cam_b_images = {int(f.split('_')[2].split('.')[0]) for f in os.listdir(cam_dir) if f.startswith(f'cam_{cam_b}_') and f.endswith('.jpg')}

        # Find common image numbers between the cameras for the pair
        common_images = cam_a_images.intersection(cam_b_images)
        print(f"Found {len(common_images)} common images between camera {cam_a} and camera {cam_b}")

        for img_num in common_images:
            cam_a_image_path = os.path.join(cam_dir, f"cam_{cam_a}_{img_num}.jpg")  # Correct filename format
            cam_b_image_path = os.path.join(cam_dir, f"cam_{cam_b}_{img_num}.jpg")  # Correct filename format
            image_paths[pair].append((cam_a_image_path, cam_b_image_path))
    
    return image_paths

# Define the base directory where the calibration images are stored
base_dir = '/home/dvij/ee206-project/ping-pong-robot/ppr_ws/src/camera_feed/camera_feed/matched_checkerboards'  # Update with your actual directory (matching folder from matchmaker)

# Define the camera pairs (camera 0-3, 1-3, 2-3)
camera_pairs = [(0, 3), (1, 3), (2, 3)]

# Load image paths for all camera pairs
image_paths = load_image_paths(base_dir, camera_pairs)

# Check if image paths were found
if not image_paths:
    print("No valid image paths found. Please check the folder structure and file naming.")
    exit(1)

# Extract the image paths for each pair
pair_03_cam0_paths = [pair[0] for pair in image_paths[(0, 3)]]
pair_03_cam3_paths = [pair[1] for pair in image_paths[(0, 3)]]
pair_13_cam1_paths = [pair[0] for pair in image_paths[(1, 3)]]
pair_13_cam3_paths = [pair[1] for pair in image_paths[(1, 3)]]
pair_23_cam2_paths = [pair[0] for pair in image_paths[(2, 3)]]
pair_23_cam3_paths = [pair[1] for pair in image_paths[(2, 3)]]

# Combine paths for each camera
cam0_all_paths = pair_03_cam0_paths
cam1_all_paths = pair_13_cam1_paths 
cam2_all_paths = pair_23_cam2_paths 
cam3_all_paths = pair_03_cam3_paths + pair_23_cam3_paths + pair_13_cam3_paths

# Perform camera calibration for each camera
mtx0, dist0, rvecs0, tvecs0, avg_re0 = calibrate_camera(cam0_all_paths)  # Camera 0 calibration
mtx1, dist1, rvecs1, tvecs1, avg_re1 = calibrate_camera(cam1_all_paths)  # Camera 1 calibration
mtx2, dist2, rvecs2, tvecs2, avg_re2 = calibrate_camera(cam2_all_paths)  # Camera 2 calibration
mtx3, dist3, rvecs3, tvecs3, avg_re3 = calibrate_camera(cam3_all_paths)  # Camera 3 calibration

# Store calibration results in lists for easy access
mtx_list = [mtx0, mtx1, mtx2, mtx3]
dist_list = [dist0, dist1, dist2, dist3]
rvecs_list = [rvecs0, rvecs1, rvecs2, rvecs3]
tvecs_list = [tvecs0, tvecs1, tvecs2, tvecs3]

# Print the calibration performance (average reprojection error) for each camera
print("Performance of individual camera calibrations (no stereo calibration yet). Average reprojection errors:")
print(f"Camera 0: {avg_re0}, Camera 1: {avg_re1}, Camera 2: {avg_re2}, Camera 3: {avg_re3}")

"""
https://correlated.kayako.com/article/30-projection-error-explanation-and-causes#:~:text=With%20a%20good%20test%20setup,or%20above%20may%20indicate%20issues.
Want reprojection error to be within 0.02-0.05 range
"""

# Perform stereo calibration between pairs of cameras
R_01, T_01 = stereo_calibrate(mtx0, dist0, mtx1, dist1, pair_03_cam0_paths, pair_03_cam0_paths)
R_12, T_12 = stereo_calibrate(mtx1, dist1, mtx2, dist2, pair_13_cam1_paths, pair_13_cam1_paths)
R_23, T_23 = stereo_calibrate(mtx2, dist2, mtx3, dist3, pair_23_cam2_paths, pair_23_cam2_paths)

# Combine rotation and translation vectors for each stereo calibration
RT01 = np.concatenate([R_01, T_01], axis=-1)
P0 = mtx0 @ RT01
print("P0_changed_coords:")
print(repr(P0))

RT12 = np.concatenate([R_12, T_12], axis=-1)
P1 = mtx1 @ RT12
print("P1_changed_coords:")
print(repr(P1))

RT23 = np.concatenate([R_23, T_23], axis=-1)
P2 = mtx2 @ RT23
print("P2_changed_coords:")
print(repr(P2))

# Camera 3 does not require stereo calibration with itself since its the last in the chain
RT3S = np.concatenate([np.eye(3), [[0], [0], [0]]], axis=-1)
P3 = mtx3 @ RT3S
print("P3_changed_coords:")
print(repr(P3))
R = np.array([[-0.60184858,  0.4579465 , -0.65426546],
       [-0.79742926, -0.3000699 ,  0.52351182],
       [ 0.04341504,  0.83680527,  0.54577658]])
T = np.array([  57.69871518,  -40.55536   , -286.55454885]).reshape((3, 1)
)
g_spatial_cam3 = np.concatenate(
    [np.concatenate([R, T], axis=1), np.array([0, 0, 0, 1]).reshape((1, 4))], axis=0)    

# Save the matrices to a .npz file
def save_calibration_results(filename, mtx_list, dist_list, P_list, R_list,g_spatial_cam3 ):
    """
    Save the intrinsic matrices (mtx_list), distortion coefficients (dist_list), and projection matrices (P_list) to a file.

    Parameters:
    - filename: The file name to save the matrices to.
    - mtx_list: List of intrinsic matrices for each camera.
    - dist_list: List of distortion coefficients for each camera.
    - P_list: List of projection matrices for each camera.
    """
    np.savez(filename, mtx=mtx_list, dist=dist_list, P=P_list,R = R_list, g = g_spatial_cam3 )

# After calibration and stereo calibration:
# Combine the projection matrices into a list
P_list = [P0, P1, P2, P3]
R_list = [RT01, RT12, RT23] 

# Save the calibration results
save_calibration_results("calibration_results.npz", mtx_list, dist_list, P_list, R_list, g_spatial_cam3)