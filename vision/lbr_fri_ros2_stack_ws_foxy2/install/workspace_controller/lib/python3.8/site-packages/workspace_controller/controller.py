import kinpy
import optas
import numpy as np
from lbr_fri_msgs.msg import LBRCommand, LBRState
from sensor_msgs.msg import JointState
from typing import Tuple

class WorkspaceVelocityController:
    
    def __init__(
        self,
        robot_description: str,
        base_link: str = "link_0",
        end_effector_link: str = "link_ee",
        world_config: kinpy.Transform = kinpy.Transform(),
        Kp: np.ndarray = np.ndarray([1, 1, 1, 1, 1, 1]),
    ) -> None:
        self.chain = kinpy.build_serial_chain_from_urdf(
            data=robot_description,
            root_link_name=base_link,
            end_link_name=end_effector_link,
        )
        # self.robot_model = optas.RobotModel(
        #     urdf_string=robot_description, time_derivs=[1]
        # )
        self.world_config = world_config.matrix()
        self.Kp = np.diag(Kp)
        self.have_stopped = False
        # self.velocity_limits = np.array([1.4, 1.4, 1.7, 1.25, 2.2, 2.3, 2.3])
        self.velocity_limits = np.array([1, 1, 1, 1, 1, 1, 1])

    def hat(self, v):
        """
        See https://en.wikipedia.org/wiki/Hat_operator or the MLS book

        Parameters
        ----------
        v : :obj:`numpy.ndarrray`
            vector form of shape 3x1, 3x, 6x1, or 6x

        Returns
        -------
        3x3 or 6x6 :obj:`numpy.ndarray`
            hat version of the vector v
        """
        if v.shape == (3, 1) or v.shape == (3,):
            return np.array([
                    [0, -v[2], v[1]],
                    [v[2], 0, -v[0]],
                    [-v[1], v[0], 0]
                ])
        elif v.shape == (6, 1) or v.shape == (6,):
            return np.array([
                    [0, -v[5], v[4], v[0]],
                    [v[5], 0, -v[3], v[1]],
                    [-v[4], v[3], 0, v[2]],
                    [0, 0, 0, 0]
                ])
        else:
            raise ValueError

    def adjoint(self, g):
        """
        Adjoint of a rotation matrix.  See the MLS book

        Parameters
        ----------
        g : 4x4 :obj:`numpy.ndarray`
            Rotation matrix

        Returns
        -------
        6x6 :obj:`numpy.ndarray` 
        """
        if g.shape != (4, 4):
            raise ValueError

        R = g[0:3,0:3]
        p = g[0:3,3]
        result = np.zeros((6, 6))
        result[0:3,0:3] = R
        result[0:3,3:6] = self.hat(p) * R
        result[3:6,3:6] = R
        return result

    def g_matrix_log(self, g: np.ndarray) -> Tuple[np.ndarray, float]:
        """
        Given a homogenous transform g, returns a unit twist xi and
        real number theta so that g = exp(xi * theta)
        """
        R = g[:3, :3]
        p = g[:3, 3]
        w, theta = self.rot_matrix_log(R)
        if w.any():
            A = np.matmul(np.eye(3) - R, self.hat(w)) + np.outer(w, w) * theta
            v = np.linalg.solve(A, p)
        else: 
            w = np.zeros(3)
            theta = np.linalg.norm(p)
            v = p / theta
        xi = np.hstack((v, w))
        return xi, theta

    def rot_matrix_log(self, R: np.ndarray) -> Tuple[np.ndarray, float]:
        """
        Given a rotation matrix R, returns the axis angle representation
        of the rotation. Returns (w, theta) so that exp(w * theta) = R.
        """
        tr_R = min(3, max(-1, sum(R[i, i] for i in range(3))))
        theta = np.arccos((tr_R - 1) / 2.0)
        w = (1 / (2 * np.sin(theta))) * np.array([R[2, 1] - R[1, 2],
                                                  R[0, 2] - R[2, 0],
                                                  R[1, 0] - R[0, 1]])
        return w, theta

    def step_control(self, target: np.ndarray, joint_state: JointState, sample_period: float) -> np.ndarray:
        """
        Parameters
        ----------
        target: 3x' :obj:`numpy.ndarray` of the desired target position in the world frame
        lbr_state: LBRState of the current joint configuration
        sample_period: float of time between calls to controller

        Returns
        -------
        7x' :obj:`numpy.ndarray` of joint positions for arm to move towards
        """
        theta = np.array(joint_state.position)
        theta[2], theta[3] = theta[3], theta[2] # Fixes an evil bug
        target_position = (np.linalg.inv(self.world_config) @ np.append(target, 1))[:3]
        current_config = self.chain.forward_kinematics(theta).matrix()
        # current_config = self.robot_model.get_global_link_transform("link_ee", theta)
        target_config = kinpy.Transform(np.array([np.sqrt(2)/2, 0, 0, np.sqrt(2)/2]), target_position).matrix()
        error_config = np.linalg.inv(current_config) @ target_config
        xi, twist_theta = self.g_matrix_log(error_config)
        error_twist = xi * twist_theta
        print(f"Twist: {error_twist}")
        if np.any(error_twist > 10) or np.any(error_twist < -10):
            print(error_config)
            print(xi)
            print(twist_theta)
            raise Exception
            return
        jacobian_pinv = np.linalg.pinv(self.chain.jacobian(theta), rcond=0.1)
        # jacobian = self.robot_model.get_global_link_geometric_jacobian("link_ee", theta)
        # jacobian_pinv = np.linalg.pinv(jacobian)
        theta_dot = jacobian_pinv @ self.Kp @ self.adjoint(current_config) @ error_twist
        # if np.any((np.abs(theta_dot) / self.velocity_limits) > 1):
            # print("Velocity too large, rescaling")
        K = np.max(np.abs(theta_dot) / self.velocity_limits)
        theta_dot = theta_dot / K
        print(f"Theta Dot: {theta_dot}")
        if np.linalg.norm(error_config[:3, 3]) < 0.01:
            if self.have_stopped:
                print("Stopped")
                return theta, np.zeros(7)
            else:
                self.have_stopped = True
                return theta + sample_period * theta_dot, np.zeros(7)
        else:
            self.have_stopped = False
            print(f"Error: {np.linalg.norm(error_config[:3, 3])}")
            return theta + sample_period * theta_dot, theta_dot

    def get_ee_position(self, joint_state: JointState):
        theta = np.array(joint_state.position)
        theta[2], theta[3] = theta[3], theta[2] # Fixes an evil bug
        current_config = self.chain.forward_kinematics(theta)
        # current_config = self.robot_model.get_global_link_transform("link_ee", theta)
        return current_config
