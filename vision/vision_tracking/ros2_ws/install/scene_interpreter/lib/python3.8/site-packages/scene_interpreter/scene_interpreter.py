from .ball_state_estimator_yolo import estimate_ball_3D_spatial_coords

import rclpy
from rclpy.node import Node
from geometry_msgs.msg import Point
from interface.msg import Scene

from cv_bridge import CvBridge
import time


class SceneInterpreter(Node):

    def __init__(self):
        super().__init__('scene_interpreter')

        self.subscription = self.create_subscription(
            Scene,
            "sync_scene",
            self.listener_callback,
            10
        )
        self.sci_publisher = self.create_publisher(Scene, "annotated_sync_scene", 10)
        self.br = CvBridge()
        self.get_logger().info('Initialized.')

        # Ask the user whether to display annotated video feeds
        self.display_annotated_video = input("Would you like to display annotated video feeds (yes/no)? ").strip().lower() == "yes"

        # Initial ball position (to be set on the first valid detection)
        self.initial_ball_position = None

    def listener_callback(self, scene):
        start = time.time()

        # Convert scene frames to OpenCV format
        frames = [self.br.imgmsg_to_cv2(frame) for frame in scene.frames]

        # Pass all available frames to the helper function
        ball_spatial_coords, error = estimate_ball_3D_spatial_coords(*frames, display_annotated=self.display_annotated_video, node=self)


        if ball_spatial_coords is None:
            self.get_logger().warn("Failed to estimate 3D ball coordinates. Skipping frame.")
        else:
            # Set the initial ball position if not already set
            if self.initial_ball_position is None:
                self.initial_ball_position = ball_spatial_coords[:3]
                self.get_logger().info(f"Initial ball position set to {self.initial_ball_position}.")

            # Compute relative position
            relative_position = [
                ball_spatial_coords[i] - self.initial_ball_position[i]
                for i in range(3)
            ]

            self.get_logger().info(f"Relative 3D Ball Coordinates: {relative_position} with error {error:.2f}")

            # Create a Point message with relative position
            p = Point()
            p.x, p.y, p.z = relative_position
            scene.ball_spatial_coords = p

            # Publish the updated scene
            self.sci_publisher.publish(scene)

        end = time.time()
        self.get_logger().info(f"Processed frame in {end - start:.2f} seconds.")

    def cleanup(self):
        # Ensure OpenCV windows are closed if used
        if self.display_annotated_video:
            cv2.destroyAllWindows()


def main(args=None):
    rclpy.init(args=args)

    sci = SceneInterpreter()
    try:
        rclpy.spin(sci)
    except KeyboardInterrupt:
        pass
    finally:
        sci.cleanup()
        sci.destroy_node()
        rclpy.shutdown()


if __name__ == '__main__':
    main()
