import numpy as np
import rclpy
import kinpy
import xacro
from rclpy.node import Node

from control_msgs.action import FollowJointTrajectory
from trajectory_msgs.msg import JointTrajectoryPoint, JointTrajectory
from sensor_msgs.msg import JointState
from geometry_msgs.msg import Point

from .jacobian_controller import WorkspaceVelocityController
from .ik_controller import IKController

import os

class ControlNode(Node):
    def __init__(self, node_name="control_node") -> None:
        super().__init__(node_name=node_name)

        # parameters
        # with open("/home/pingpongproject/code/ping-pong-robot/lbr_fri_ros2_stack_ws_foxy2/src/lbr_fri_ros2_stack/control/workspace_controller/urdf/iiwa14.urdf", "r") as f:
            # robot_description = f.read()

        robot_description = xacro.process("/home/pingpongproject/code/ping-pong-robot/lbr_fri_ros2_stack_ws_foxy2/src/lbr_fri_ros2_stack/lbr_description/urdf/iiwa14/iiwa14.urdf.xacro")
        # robot_description = "/home/pingpongproject/code/ping-pong-robot/lbr_fri_ros2_stack_ws_foxy2/src/lbr_fri_ros2_stack/lbr_description/urdf/iiwa14/iiwa14.urdf.xacro"

        self.declare_parameter("robot_description", robot_description)
        self.declare_parameter("base_link", "link_0")
        self.declare_parameter("end_effector_link", "link_ee")
        
        rot = np.array([np.sqrt(2) / 2, 0, 0, np.sqrt(2) / 2]) # -pi/2 z rotation
        pos = np.array([0, -1.9416, -0.44926])                    # coords of KUKA base in world frame
        self.world_config = kinpy.Transform(rot, pos)
        self.target = None

        # self.controller = WorkspaceVelocityController(
            # robot_description=str(self.get_parameter("robot_description").value),
            # base_link=str(self.get_parameter("base_link").value),
            # end_effector_link=str(self.get_parameter("end_effector_link").value),
            # world_config=self.world_config,
            # Kp=np.array([1, 1, 1, 1, 1, 1])
        # )
        self.controller = IKController(
            robot_description=str(self.get_parameter("robot_description").value),
            base_link=str(self.get_parameter("base_link").value),
            end_effector_link=str(self.get_parameter("end_effector_link").value),
            world_config=self.world_config
        )

        self.sample_period = 0.1
        self.counter = 0
        self.ignore_states = 100

        # publishers and subscribers
        self.joint_state_sub = self.create_subscription(
            JointState, "/joint_states", self.on_joint_state, 1
        )

        self.target_sub = self.create_subscription(
            Point, "/target_prediction", self.on_target, 10
        )
        
        self.joint_trajectory_pub = self.create_publisher(
            JointTrajectory, "/joint_trajectory_controller/joint_trajectory", 1
        )


    def on_target(self, target: Point) -> None:
        print("Target received")
        self.target = np.array([target.x, target.y, target.z])


    def on_joint_state(self, joint_state: JointState) -> None:
        self.counter += 1
        if self.counter % self.ignore_states != 0:
            return

        print(f"Current config: {self.controller.get_ee_position(joint_state)}")
        print(f"Current theta: {joint_state.position}")
        return

        if self.target is None:
            return
        #     target_x = float(input("Target x: "))
        #     target_y = float(input("Target Y: "))
        #     target_z = float(input("Target Z: "))
        #     self.target = np.array([target_x, target_y, target_z])

        joint_trajectory = JointTrajectory()
        joint_trajectory.joint_names = ['A1', 'A2', 'A3', 'A4', 'A5', 'A6', 'A7']
        point = JointTrajectoryPoint()

        # position, velocity = self.controller.step_control(self.target, joint_state, sample_period=self.sample_period)
        # point.positions = position.tolist()
        # point.velocities = velocity.tolist()
        # point.time_from_start.sec = int(self.sample_period)
        # point.time_from_start.nanosec = int((self.sample_period - int(self.sample_period)) * 1e9)
        # joint_trajectory.points = [point]

        position, required_time = self.controller.step_control(self.target, joint_state)
        print(f"Goal Theta: {position}")
        if position is None:
            return
        required_time += 0.2
        print(f"Time: {required_time}")
        point.positions = position.tolist()
        point.time_from_start.sec = int(required_time)
        nanosecs = int((required_time - int(required_time)) * 1e9)
        point.time_from_start.nanosec = max(min(nanosecs, 4294967295), 0)   # Keep nanoseconds in range [0, 4294967296)
        joint_trajectory.points = [point]

        self.joint_trajectory_pub.publish(joint_trajectory)


def main(args=None):
    rclpy.init(args=args)
    control_node = ControlNode()
    rclpy.spin(control_node)
    rclpy.shutdown()
