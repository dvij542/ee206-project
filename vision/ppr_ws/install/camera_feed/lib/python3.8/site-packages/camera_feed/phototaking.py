import time
import os
import threading
import cv2
import queue
from PIL import Image as PILImage
import numpy as np
import shutil
import gi
from gi.repository import Aravis
import signal

# Global shutdown event and capture synchronization event
shutdown_event = threading.Event()
capture_trigger = threading.Event()

# Global frame queues for each camera
frame_queues = {}

# Define directories to save calibration images for each camera
save_dirs = {
    0: "./calibration_images/camera_0",
    1: "./calibration_images/camera_1",
    2: "./calibration_images/camera_2",
    3: "./calibration_images/camera_3"
}

# Create directories if they don't exist
for save_dir in save_dirs.values():
    os.makedirs(save_dir, exist_ok=True)

# Global lock for synchronizing image number calculation
image_number_lock = threading.Lock()

def signal_handler(signum, frame):
    """Handle termination signals (Ctrl+C or kill)."""
    print("\nSignal received, initiating shutdown...")
    shutdown_event.set()

# Register signal handlers
signal.signal(signal.SIGINT, signal_handler)  # Handle Ctrl+C
signal.signal(signal.SIGTERM, signal_handler)  # Handle kill

def wait_until_next_start_point():
    start_point = 5
    current_time = time.time()
    next_start_time = (current_time // start_point + 1) * start_point
    time.sleep(next_start_time - current_time)

def get_next_image_number(save_dir):
    """Get the next image number based on existing files in the directory."""
    with image_number_lock:
        if not os.path.exists(save_dir):
            return 0

        existing_files = [f for f in os.listdir(save_dir) if f.startswith("frame_") and f.endswith(".png")]
        if not existing_files:
            return 0

        numbers = []
        for file in existing_files:
            try:
                num = int(file.split('_')[1].split('.')[0])
                numbers.append(num)
            except ValueError:
                continue

        return max(numbers) + 1 if numbers else 0

class PingPongTracker:
    def __init__(self, cam_num=0, model_path="best.pt"):
        self.cam_num = cam_num
        frame_queues[cam_num] = queue.Queue(maxsize=10)

        # Camera settings
        EXPOSURE_TIME = 100000
        cameras = {
            "Daheng Imaging-2BA200003814-FDN21120585": 0,
            "Daheng Imaging-2BA200003827-FDN21120598": 1,
            "Daheng Imaging-2BA200003813-FDN21120584": 2,
            "Daheng Imaging-2BA200003815-FDN21120586": 3,
        }

        camera_id = next((key for key, value in cameras.items() if value == cam_num), None)
        assert camera_id is not None, f"Camera ID not found for camera {cam_num}"

        # Set up camera
        Aravis.enable_interface("Fake")
        self.cam = Aravis.Camera.new(camera_id)
        self.cam.set_string('AcquisitionFrameRateMode', 'On')
        self.cam.set_string('BalanceWhiteAuto', 'Continuous')
        self.cam.set_exposure_time(EXPOSURE_TIME)
        self.cam.get_device().set_float_feature_value('AcquisitionFrameRate', 120.0)

        device = self.cam.get_device()
        device.set_string_feature_value("AcquisitionMode", "Continuous")
        payload = self.cam.get_payload()
        self.stream = self.cam.create_stream(None, None)

        for i in range(5):
            self.stream.push_buffer(Aravis.Buffer.new_allocate(payload))

        [_, _, self.width, self.height] = self.cam.get_region()

        # Determine the starting image number for this camera
        self.next_image_number = get_next_image_number(save_dirs[cam_num])

    def process_frame(self, frame):
        if shutdown_event.is_set():
            return None

        # Save images for calibration instead of ball tracking
        save_dir = save_dirs.get(self.cam_num)
        if save_dir:
            image_filename = os.path.join(save_dir, f"frame_{self.next_image_number:04d}.png")
            cv2.imwrite(image_filename, frame)
            print(f"Saved calibration image for Camera {self.cam_num}: {image_filename}")
            self.next_image_number += 1  # Increment the image number for the next save

        return frame

    def run(self):
        try:
            wait_until_next_start_point()
            print(f"Starting acquisition for Camera {self.cam_num}")
            self.cam.start_acquisition()

            while not shutdown_event.is_set():
                # Wait for the global trigger before capturing the frame
                capture_trigger.wait()

                try:
                    buffer = self.stream.pop_buffer()
                    if buffer:
                        data_from_buffer = buffer.get_data()
                        image_pil = PILImage.frombytes('L', (self.width, self.height), data_from_buffer)
                        image_rgb = cv2.cvtColor(np.array(image_pil), cv2.COLOR_BAYER_RG2RGB)

                        saved_frame = self.process_frame(image_rgb)
                        if saved_frame is None:  # Check for shutdown
                            break

                        self.stream.push_buffer(buffer)

                except Exception as e:
                    print(f"Error in camera {self.cam_num} loop: {e}")
                    if not shutdown_event.is_set():
                        shutdown_event.set()
                    break

        except Exception as e:
            print(f"Fatal error in camera {self.cam_num}: {e}")
            shutdown_event.set()
        finally:
            print(f"Cleaning up camera {self.cam_num}")
            try:
                self.cam.stop_acquisition()
            except Exception as e:
                print(f"Error stopping acquisition for camera {self.cam_num}: {e}")

def display_thread(camera_numbers, output_width=1280, output_height=720):
    """Separate thread for handling all window displays."""
    while not shutdown_event.is_set():
        frames = []
        for cam_num in camera_numbers:
            try:
                frame = frame_queues[cam_num].get_nowait()
                frames.append(frame)

            except queue.Empty:
                frames.append(np.zeros((output_height, output_width, 3), dtype=np.uint8))

        if frames:
            combined_frame = np.hstack(frames)
            resized_frame = cv2.resize(combined_frame, (output_width, output_height))
            cv2.imshow("Multi-Camera Tracking", resized_frame)

        if cv2.waitKey(1) & 0xFF == ord('q'):
            print("'q' pressed in display window")
            shutdown_event.set()
            break

    cv2.destroyAllWindows()

class MultiCameraSystem:
    def __init__(self, camera_numbers):
        self.camera_numbers = camera_numbers
        self.trackers = []
        self.threads = []
        self.active_cameras = []

        for cam_num in camera_numbers:
            try:
                tracker = PingPongTracker(cam_num=cam_num)
                self.trackers.append(tracker)
                self.threads.append(threading.Thread(target=tracker.run, daemon=True))
                self.active_cameras.append(cam_num)
            except Exception as e:
                print(f"Camera {cam_num} initialization failed: {e}")

        if not self.active_cameras:
            raise RuntimeError("No functional cameras available!")

        # Add display thread
        self.display_thread = threading.Thread(target=display_thread, args=(self.active_cameras,))
        self.threads.append(self.display_thread)

    def start(self):
        """Start all camera threads."""
        print(f"Starting cameras: {self.active_cameras}")
        for thread in self.threads:
            thread.start()

    def stop(self):
        """Stop all cameras and threads."""
        print("Stopping all cameras...")
        shutdown_event.set()

        for thread in self.threads:
            if thread.is_alive():
                thread.join(timeout=5.0)

        cv2.destroyAllWindows()

    def capture_single_image(self):
        """Capture a single image from all cameras."""
        print("Capturing a single image for all cameras...")
        capture_trigger.set()  # Trigger cameras to capture image
        time.sleep(0.01)        # Allow some time for capture
        capture_trigger.clear()  # Reset the trigger for the next capture

def clear_existing_images():
    """Prompt the user to confirm if they want to clear existing images."""
    response = input("Do you want to clear existing calibration images? (y/n): ")
    if response.lower() == 'y':
        for save_dir in save_dirs.values():
            try:
                for filename in os.listdir(save_dir):
                    file_path = os.path.join(save_dir, filename)
                    if os.path.isfile(file_path):
                        os.remove(file_path)
                print(f"Cleared existing images in {save_dir}")
            except Exception as e:
                print(f"Failed to clear images in {save_dir}: {e}")
    else:
        print("Existing images not cleared.")

if __name__ == "__main__":
    clear_existing_images()

    multi_camera_system = MultiCameraSystem(camera_numbers=[0, 1, 2, 3])
    multi_camera_system.start()

    try:
        while not shutdown_event.is_set():
            # Capture images every 5 seconds
            multi_camera_system.capture_single_image()
            time.sleep(5)  # Wait for 5 seconds before the next capture
    except KeyboardInterrupt:
        print("KeyboardInterrupt received. Stopping cameras...")
        multi_camera_system.stop()
